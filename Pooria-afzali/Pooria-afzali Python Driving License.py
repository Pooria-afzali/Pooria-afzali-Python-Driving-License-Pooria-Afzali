#!/usr/bin/env python
# coding: utf-8

# # **Python Driving License: Analyzing battery charge/discharge data (nucleation overpotential)**
# 
# In a battery cell charge/discharge test run by a potentiostat, you can apply different current densities, potentials, and control various parameters such as capacity, time, etc., to conduct your test and analyze the electrochemical behavior of your battery cell. The charge/discharge plot (Voltage versus Time) is one of the most critical pieces of data obtained from this test, from which many pieces of information can be interpreted. One of the most significant factors affecting a battery is nucleation overpotential.The voltage difference between the most dropped point and the plateau is called Nucleation overpotential. 
# 
# The objective of this script is to take the data generated by the potentiostat, process it, and conduct computations to derive the pertinent values associated with the nucleation overpotential in a battery cell.
# 
# 
# ![Untitled-3.png](attachment:Untitled-3.png)

#  **Now filtering data and selecting the desired region**
#  
#  The nucleation overpotential is determined from the discharging (plating) portion of the V-T diagram, so we simply filter out the data from the charging process here. Also, if the current density (C_rate) changes, it will get the mean and std values of eaxh group in the same Crates.
#  
# ![filtered.png](attachment:filtered.png)

# #Finding the minimum Voltage in the filtered region
# 
# The minimum voltage at the discharging stage is calulated here, also the corresponding datapoint or time is shown.
# 
# ![download-2.png](attachment:download-2.png)
# 

# We filter out data before the minimum voltage and then identify the maximum voltage within each cycle. Afterward, we calculate the absolute value of the difference between the maximum and minimum voltages. 
# 
# 
# ![download.png](attachment:download.png)

# In[35]:


#Importing libraries 
import pandas as pd
import matplotlib.pyplot as plt

#Reading the CSV file
df=pd.read_csv(r"C:\Users\pafzali\OneDrive - Politecnico di Milano\Desktop\python\1.csv")

#Filtering the columns based on dicharge step
filtered_df=df[df['Step Type']=='CC DChg']

#Finding the minimum voltage index in each Cycle
min_voltage_index_of_cycle = filtered_df.groupby('Cycle Index')['Voltage(V)'].idxmin()

#storing the calculated data for each cycle after being filtered
cycle_indices=[]
crate_values=[]
nucleation_overpotential=[]
#loop for going over through the cycles 
for cycle_index in range(1, 31):
    min_voltage_index= min_voltage_index_of_cycle.loc[cycle_index]
    current_value= df.loc[min_voltage_index,'Current(A)']
    #calculating crate
    capacity=0.000785
    c_rate= round(abs(current_value / capacity),2)

    cycle_indices.append(cycle_index)
    crate_values.append(c_rate)

#Calculating  nucleation overpotential
 #filtering rows in the dataframe where the Cycle Index is equal to the current cycle index 
    cycle_data= filtered_df[(filtered_df['Cycle Index'] == cycle_index) & (filtered_df.index >= min_voltage_index)]
    #and filtering rows where the index is greater than or equal to the previously determined minimum voltage index. 
    #so upto here the data frame corresponds to the data or the current cycle starting from the minimum voltage point.
    
    #Calculating maximum and minimum voltage
    max_voltage= cycle_data ['Voltage(V)'].max()
    min_voltage= cycle_data['Voltage(V)'].min()
    voltage_difference= abs(max_voltage - min_voltage)

    nucleation_overpotential.append(voltage_difference)
#Create DataFrame
data = pd.DataFrame({'Cycle Index': cycle_indices, 'C-rate': crate_values, 'Nucleation Overpotential': nucleation_overpotential})
print(data)


# In[37]:


#Nucleation overpotential vs cycle index plot with modified size
plt.figure(figsize=(12, 6))


#gtting crate values from the C-rate column
c_rates=set(data['C-rate'])

# going through each C-rate and plot the corresponding data
for x, c_rate in enumerate(c_rates):
    #filtering the data for the current C-rate
    cycle_data = data[data['C-rate']==c_rate]

#plot the data with a distinct color for each cycle
    plt.plot(
        cycle_data['Cycle Index'], cycle_data['Nucleation Overpotential'], # x and Y-axis data (Cycle Index/Nucleation Overpotential)
         
        marker='o', linestyle='-',            # marker and line styles
        
        label=f'{c_rate}C')                   # label for the legend


plt.xlabel('Cycle')
plt.ylabel('Nucleation Overpotential (V)')
plt.title('Nucleation Overpotential vs. Cycle Index')
plt.legend()
plt.grid(False)

plt.show()


# In[38]:


#Grouping the data by C-rate values
groupping_by_crate = data.groupby('C-rate')

#to select the 'Nucleation Overpotential' column for each C-rate group
nucleation_overpotential_per_crate= groupping_by_crate['Nucleation Overpotential']

#Mean for each C-rate group
mean_per_crate =nucleation_overpotential_per_crate.mean()

#standard deviation for each C-rate group
std_per_crate =nucleation_overpotential_per_crate.std()

#Combining the mean and std into a DataFrame
mean_and_std_per_crate= pd.DataFrame({'mean': mean_per_crate, 'std': std_per_crate})

#define index for each  C-rate values and make it part of the DataFrame
calculations_per_crate =  mean_and_std_per_crate.reset_index()

#plot of average nucleation overpotential versus Crate with error bars
plt.figure(figsize=(12, 6))
plt.errorbar(calculations_per_crate['C-rate'], calculations_per_crate['mean'], yerr=calculations_per_crate['std'],
marker='o', linestyle='-', capsize=4, label='Average Nucleation Overpotential')
plt.xlabel('C-rate')
plt.ylabel('Nucleation Overpotential (V)')
plt.title('Average Nucleation Overpotential with Standard Deviation vs. C-rate')
plt.grid(True)
plt.xticks(calculations_per_crate['C-rate'])  # Set x-axis ticks to only C-rate units
plt.show()

#Printing the mean value for each crate

print(calculations_per_crate[['C-rate', 'mean']])    


# In[ ]:





# In[ ]:





# 
